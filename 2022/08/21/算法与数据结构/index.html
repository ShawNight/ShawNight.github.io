<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法与数据结构 | Kirito博客</title><meta name="author" content="Kirito"><meta name="copyright" content="Kirito"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录一些算法题目">
<meta property="og:type" content="article">
<meta property="og:title" content="算法与数据结构">
<meta property="og:url" content="http://example.com/2022/08/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Kirito博客">
<meta property="og:description" content="记录一些算法题目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png">
<meta property="article:published_time" content="2022-08-21T14:20:05.000Z">
<meta property="article:modified_time" content="2022-08-21T14:46:14.727Z">
<meta property="article:author" content="Kirito">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法与数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-08-21 22:46:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kirito博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法与数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-21T14:20:05.000Z" title="发表于 2022-08-21 22:20:05">2022-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-21T14:46:14.727Z" title="更新于 2022-08-21 22:46:14">2022-08-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法与数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h3 id="一、栈、队列与堆"><a href="#一、栈、队列与堆" class="headerlink" title="一、栈、队列与堆"></a>一、栈、队列与堆</h3><p>主要记录做过的一些算法题，题目基本上都是来自与leecode</p>
<p>栈：<strong>先进后出的线性表</strong>；栈(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。在编程中，例如C&#x2F;C++中，所有的局部变量都是从栈中分配内存空间，实际上也不是什么分配，只是从栈顶向上用就行，在退出函数的时候，只是修改栈指针就可以把栈中的内容销毁，所以速度最快</p>
<p>堆：（Heap)是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请&#x2F;给予的过程，C&#x2F;C++分别用malloc&#x2F;New请求分配Heap，用free&#x2F;delete销毁内存。由于从操作系统管理的内存分配所以在分配和销毁时都要占用时间，所以用堆的效率低的多！但是堆的好处是可以做的很大，C&#x2F;C++对分配的Heap是不初始化的。</p>
<p>[		<code>堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。&#123;堆是指程序运行是申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)]()</code></p>
<p>队列：<strong>先进后出的线性表</strong></p>
<h6 id="例1：使用队列实现栈"><a href="#例1：使用队列实现栈" class="headerlink" title="例1：使用队列实现栈"></a>例1：使用队列实现栈</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; temp_data;</span><br><span class="line">        temp_data.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!_data.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            temp_data.<span class="built_in">push</span>(_data.<span class="built_in">front</span>());</span><br><span class="line">            _data.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!temp_data.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            _data.<span class="built_in">push</span>(temp_data.<span class="built_in">front</span>());</span><br><span class="line">            temp_data.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x=_data.<span class="built_in">front</span>();</span><br><span class="line">        _data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="例2：使用栈实现队列"><a href="#例2：使用栈实现队列" class="headerlink" title="例2：使用栈实现队列"></a>例2：使用栈实现队列</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; temp_data;</span><br><span class="line">        temp_data.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!_data.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            temp_data.<span class="built_in">push</span>(_data.<span class="built_in">top</span>());</span><br><span class="line">            _data.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!temp_data.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            _data.<span class="built_in">push</span>(temp_data.<span class="built_in">top</span>());</span><br><span class="line">            temp_data.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x= _data.<span class="built_in">top</span>();</span><br><span class="line">        _data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _data.<span class="built_in">top</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _data.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="例3：带有min的栈"><a href="#例3：带有min的栈" class="headerlink" title="例3：带有min的栈"></a>例3：带有min的栈</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        _data.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(_min.<span class="built_in">empty</span>()||_min.<span class="built_in">top</span>()&gt;x)&#123;</span><br><span class="line">            _min.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            _min.<span class="built_in">push</span>(_min.<span class="built_in">top</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _min.<span class="built_in">pop</span>();</span><br><span class="line">        _data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _min.<span class="built_in">top</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _data.<span class="built_in">top</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _data.<span class="built_in">empty</span>();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; _data;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; _min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="例4：合法的出栈序列"><a href="#例4：合法的出栈序列" class="headerlink" title="例4：合法的出栈序列"></a>例4：合法的出栈序列</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_is_valid_order</span><span class="params">(queue&lt;<span class="type">int</span>&gt; &amp;order)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="type">int</span> n=order.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        S.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!S.<span class="built_in">empty</span>()&amp;&amp;order.<span class="built_in">front</span>()==S.<span class="built_in">top</span>())&#123;</span><br><span class="line">            order.<span class="built_in">pop</span>();</span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h6 id="例5：第K大的数"><a href="#例5：第K大的数" class="headerlink" title="例5：第K大的数"></a>例5：第K大的数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> k)</span></span>&#123;	<span class="comment">//最小堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; Q; <span class="comment">//优先级队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Q.<span class="built_in">size</span>()&lt;k)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Q.<span class="built_in">top</span>()&lt;nums[i])&#123;</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            Q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例6：寻找中位数"><a href="#例6：寻找中位数" class="headerlink" title="例6：寻找中位数"></a>例6：寻找中位数</h6><p>动态维护一个最大堆与一个最小堆，最大堆存储一半数据，最小堆存储一半数据，维持最大堆的堆顶比最小堆的堆顶小.</p>
<p>情况1：</p>
<p>最大堆与最小堆个数相同，新元素小于最大堆，添加最大堆；新元素大于最大堆，添加最小堆。</p>
<p>情况2：</p>
<p>最大堆比最小堆多一个元素，且新元素小于最大堆：将最大堆的堆顶push进入最小堆；将最大堆的堆顶移除；将新元素添加至最大堆。</p>
<p>最大堆比最小堆多一个元素，且新元素大于最大堆：新元素直接push进入最小堆。</p>
<p>情况3：</p>
<p>最大堆比最小堆少一个元素，且新元素小于最大堆：新元素直接push进入最大堆。</p>
<p>最大堆比最小堆少一个元素，且新元素大于最大堆：将最小堆的堆顶push进入最大堆；将最小堆的堆顶移除；将新元素添加至最小堆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MediaFinder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MediaFinder</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(big_queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            big_queue.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(big_queue.<span class="built_in">size</span>()==small_queue.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(big_queue.<span class="built_in">top</span>()&gt;=num)&#123;</span><br><span class="line">                big_queue.<span class="built_in">push</span>(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                small_queue.<span class="built_in">push</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(big_queue.<span class="built_in">size</span>()&gt;small_queue.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;big_queue.<span class="built_in">top</span>())</span><br><span class="line">                small_queue.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                small_queue.<span class="built_in">push</span>(big_queue.<span class="built_in">top</span>());</span><br><span class="line">                big_queue.<span class="built_in">pop</span>();</span><br><span class="line">                big_queue.<span class="built_in">push</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;small_queue.<span class="built_in">top</span>())</span><br><span class="line">                big_queue.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                big_queue.<span class="built_in">push</span>(small_queue.<span class="built_in">top</span>());</span><br><span class="line">                small_queue.<span class="built_in">pop</span>();</span><br><span class="line">                small_queue.<span class="built_in">push</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(big_queue.<span class="built_in">size</span>()&gt;=small_queue.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> big_queue.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> small_queue.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt;  small_queue; <span class="comment">//最小堆 //升序队列</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt;  big_queue;	<span class="comment">//最大堆 //降序队列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h3><h3 id="三、贪心算法"><a href="#三、贪心算法" class="headerlink" title="三、贪心算法"></a>三、贪心算法</h3><p>$\textcolor{red}{基本概念}$：所谓贪心算法是指，在对问题求解时，总是<strong>做出在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的<strong>局部最优解</strong>。<br> 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）<br> <strong>所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>
<p>$\textcolor{red}{基本思路}$：</p>
<ul>
<li>建立数学模型来描述问题</li>
<li>把求解的问题分成若干个子问题</li>
<li>对每个子问题求解，得到子问题的局部最优解</li>
<li>把子问题的解局部最优解合成原来问题的一个解</li>
</ul>
<p>$\textcolor{red}{存在的问题}$：</p>
<ul>
<li>不能保证求得的最后解是最佳的</li>
<li>不能用来求最大值或最小值的问题</li>
<li>只能求满足某些约束条件的可行解的范围</li>
</ul>
<h6 id="例1：分糖果"><a href="#例1：分糖果" class="headerlink" title="例1：分糖果"></a>例1：分糖果</h6><blockquote>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
</blockquote>
<p>假设g&#x3D;[5,10,2,9,15,9] ; s&#x3D;[6,1,20,3,8];</p>
<p>先进行排序g&#x3D;[ 2,5,9,9,10,15];  s&#x3D;[1,3,6,8,20]</p>
<p>1、如果饼干不能满足某个孩子，那么肯定不能满足需求因子更大的孩子；</p>
<p>2、如果某个饼干可以满足某个孩子，那么不需要用更大的糖果满足他；</p>
<p>综上可知，尽量让更大的饼干满足需求因子更大的孩子；那么从小到大遍历饼干，并且从小到大尝试是否可以满足某个孩子，满足的话，继续从下一个饼干尝试是否能满足下一个孩子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g,vector&lt;<span class="type">int</span>&gt;&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cookie=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cookie&lt;s.<span class="built_in">size</span>()&amp;&amp;child&lt;g.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[cookie]&gt;=g[child])</span><br><span class="line">            child++;</span><br><span class="line">        cookie++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例2：摇摆序列"><a href="#例2：摇摆序列" class="headerlink" title="例2：摇摆序列"></a>例2：摇摆序列</h6><blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<p>示例 1：输入：nums &#x3D; [1,7,4,9,2,5]  输出：6</p>
<p>输入：nums &#x3D; [1,17,5,10,13,15,10,5,16,8]  输出：7      解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</p>
</blockquote>
<p>分析：</p>
<p>状态转换机：</p>
<p><img src="E:\文件资料\C++\image-20210701233908002.png" alt="image-20210701233908002"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&lt;nums[i])&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;len&amp;&amp;nums[i<span class="number">-1</span>]&lt;=nums[i])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&gt;nums[i])&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;len&amp;&amp;nums[i<span class="number">-1</span>]&gt;=nums[i])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">状态机：</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> BEGIN=<span class="number">0</span>;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> UP=<span class="number">1</span>;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> DOWN=<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> START=BEGIN;</span><br><span class="line">        <span class="type">int</span> max_length=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(START)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> BEGIN:</span><br><span class="line">                    <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&lt;nums[i])&#123;</span><br><span class="line">                        START=UP;</span><br><span class="line">                        max_length++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&gt;nums[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        START=DOWN;</span><br><span class="line">                        max_length++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UP:</span><br><span class="line">                    <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&gt;nums[i])&#123;</span><br><span class="line">                        START=DOWN;</span><br><span class="line">                        max_length++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOWN:</span><br><span class="line">                    <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&lt;nums[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        START=UP;</span><br><span class="line">                        max_length++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="例3：移除K个数字（402）"><a href="#例3：移除K个数字（402）" class="headerlink" title="例3：移除K个数字（402）"></a>例3：移除K个数字（402）</h6><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;1432219&quot;, k = 3</span><br><span class="line">输出：&quot;1219&quot;</span><br><span class="line">解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;10200&quot;, k = 1</span><br><span class="line">输出：&quot;200&quot;</span><br><span class="line">解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;10&quot;, k = 2</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：从原数字移除所有的数字，剩余为空就是 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= num.length &lt;= 105</code></li>
<li><code>num</code> 仅由若干位数字（0 - 9）组成</li>
<li>除了 <strong>0</strong> 本身之外，<code>num</code> 不含任何前导零</li>
</ul>
<p>分析：要想数最小则，越高位的数字越小，数字越小，创建一个栈，每次往里添加数据，如果要添加的数比栈顶小，则移除栈顶，相应k–；直到栈为空或者栈顶元素大于当前数或者没有可以移除的次数k，则把当前数添加入栈顶。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; digit: num) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; stk.<span class="built_in">back</span>() &gt; digit &amp;&amp; k) &#123;</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">            stk.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">bool</span> isLeadingZero = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; digit: stk) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeadingZero &amp;&amp; digit == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isLeadingZero = <span class="literal">false</span>;</span><br><span class="line">            ans += digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="string">&quot;&quot;</span> ? <span class="string">&quot;0&quot;</span> : ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="例4：跳跃游戏-55"><a href="#例4：跳跃游戏-55" class="headerlink" title="例4：跳跃游戏(55)"></a>例4：跳跃游戏(55)</h6><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(max&lt;len&amp;&amp;i&lt;max)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="type">int</span> now=i+nums[i];</span><br><span class="line">        max=max&lt;now?now:max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max&lt;len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例5：跳跃游戏2-（45）"><a href="#例5：跳跃游戏2-（45）" class="headerlink" title="例5：跳跃游戏2 （45）"></a>例5：跳跃游戏2 （45）</h6><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p>
<p>算法思路：</p>
<p>1、设置current_max_index为当前可达到的最远位置；</p>
<p>2、设置pre_max_max_index为遍历各个位置的过程中，各个位置可达到的最远位置；</p>
<p>3、设置jump_min为最少跳跃的次数</p>
<p>4、利用i遍历nums数组，若i超过current_max_index,jump_min加1，current_max_index&#x3D;pre_max_max_index</p>
<p>5、遍历过程中，若nums[i]+i(index[i])更大，则更新pre_max_max_index&#x3D;nums[i]+i</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> current_max_index=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> pre_max_max_index=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> jump_min=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;current_max_index)&#123;</span><br><span class="line">            jump_min+=<span class="number">1</span>;</span><br><span class="line">            current_max_index=pre_max_max_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre_max_max_index&lt;nums[i]+i)&#123;</span><br><span class="line">            pre_max_max_index=nums[i]+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jump_min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例6：射击气球-452"><a href="#例6：射击气球-452" class="headerlink" title="例6：射击气球(452)"></a>例6：射击气球(452)</h6><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] &#x3D; [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),[](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;lhs,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs[<span class="number">0</span>]&lt;rhs[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> min=points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> counts=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i][<span class="number">0</span>]&gt;min)&#123;</span><br><span class="line">            min=points[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(points[i][<span class="number">1</span>]&lt;max)&#123;</span><br><span class="line">            max=points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min&gt;max)&#123;</span><br><span class="line">            counts++;</span><br><span class="line">            max=points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例7：最优加油方法（2431）"><a href="#例7：最优加油方法（2431）" class="headerlink" title="例7：最优加油方法（2431）"></a>例7：最优加油方法（2431）</h6><p>已知在一条公路，有一个起点与一个终点，这之间有n个加油站；已知从这n个加油站到终点的距离d与各个加油站可加油的量1，起点位置至终点的距离L与起始时刻油箱中汽油量P；假设使用1个单位的汽油既可以走1个单位的距离，油箱没有上限，最少加几次油，可以从起点开至终点。</p>
<p>算法思路：</p>
<p>1、设置一个最大堆，用来存储经过的加油站的汽油量。</p>
<p>2、按照从起点至终点的方向，遍历各个加油站之间的距离。</p>
<p>3、每次需要走两个加油站之间的距离d，如果发现汽油不够走距离d时，从最大堆中取出一个油量添加，直到可以足够走距离的。</p>
<p>4、如果把最大堆的汽油都添加仍然不够行进距离d，则无法到达终点，</p>
<p>5、当前油量P减少d。</p>
<p>6、将当前加油站汽油量添加至最大堆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;a,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first&gt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_minimun</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> P,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; &amp;stop)</span></span>&#123; <span class="comment">//L为起点到终点的距离，P为起始点的油量,pair&lt;加油站至终点的距离，加油站的油量</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; Q;  <span class="comment">//存储油量的最大堆</span></span><br><span class="line">    <span class="type">int</span> result=<span class="number">0</span>;           <span class="comment">//记录加油的次数</span></span><br><span class="line">    stop.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>)); <span class="comment">//  将终点作为一个停靠点，添加至stop数组</span></span><br><span class="line">    <span class="built_in">sort</span>(stop.<span class="built_in">begin</span>(),stop.<span class="built_in">end</span>(),cmp);  <span class="comment">//  已停靠点至终点的距离从大到小排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stop.<span class="built_in">size</span>();i++)&#123;     <span class="comment">//遍历各个停靠点</span></span><br><span class="line">        <span class="type">int</span> dis=L-stop[i].first;        </span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()&amp;&amp;P&lt;dis)&#123;</span><br><span class="line">            P+=Q.<span class="built_in">top</span>();</span><br><span class="line">            result++;</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(P&lt;dis)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        P=P-dis;</span><br><span class="line">        Q.<span class="built_in">push</span>(stop[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、递归回溯与分治"><a href="#四、递归回溯与分治" class="headerlink" title="四、递归回溯与分治"></a>四、递归回溯与分治</h3><p>分治算法：将一个规模为N的问题分解成为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解后进行合并，就可以得到原问题的解。</p>
<p>一般步骤:</p>
<p>1、分解，将要解决的问题划分为若干个规模较小的同类问题；</p>
<p>2、求解，当子问题规模划分的足够小时，用较简单的问题求解；</p>
<p>3、合并，按照原问题的要求，将求解后的子问题逐层合并。</p>
<h6 id="例1：求子集"><a href="#例1：求子集" class="headerlink" title="例1：求子集"></a>例1：求子集</h6><h6 id="例2：生产括号"><a href="#例2：生产括号" class="headerlink" title="例2：生产括号"></a>例2：生产括号</h6><h6 id="例3：组合数之和"><a href="#例3：组合数之和" class="headerlink" title="例3：组合数之和"></a>例3：组合数之和</h6><h6 id="例4：N皇后"><a href="#例4：N皇后" class="headerlink" title="例4：N皇后"></a>例4：N皇后</h6><h6 id="例5：归并排序"><a href="#例5：归并排序" class="headerlink" title="例5：归并排序"></a>例5：归并排序</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort_two_vec</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;sub_vec1,vector&lt;<span class="type">int</span>&gt; &amp;sub_vec2,vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;sub_vec1.<span class="built_in">size</span>()&amp;&amp;j&lt;sub_vec2.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(sub_vec1[i]&lt;=sub_vec2[j])&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(sub_vec1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(sub_vec2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;sub_vec1.<span class="built_in">size</span>();i++)</span><br><span class="line">        vec.<span class="built_in">push_back</span>(sub_vec1[i]);</span><br><span class="line">    <span class="keyword">for</span>(j;j&lt;sub_vec2.<span class="built_in">size</span>();j++)</span><br><span class="line">        vec.<span class="built_in">push_back</span>(sub_vec2[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec.<span class="built_in">size</span>()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=vec.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sub_vec1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sub_vec2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mid;i++)</span><br><span class="line">        sub_vec1.<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">        sub_vec2.<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">    <span class="built_in">merge_sort</span>(sub_vec1);</span><br><span class="line">    <span class="built_in">merge_sort</span>(sub_vec2);</span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">merge_sort_two_vec</span>(sub_vec1,sub_vec2,vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例6：逆序数"><a href="#例6：逆序数" class="headerlink" title="例6：逆序数"></a>例6：逆序数</h6><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>示例：</p>
<p>输入：nums &#x3D; [5,2,6,1]<br>输出：[2,1,1,0]<br>解释：<br>5 的右侧有 2 个更小的元素 (2 和 1)<br>2 的右侧仅有 1 个更小的元素 (1)<br>6 的右侧有 1 个更小的元素 (1)<br>1 的右侧有 0 个更小的元素</p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4</p>
<h3 id="五、二叉树与图"><a href="#五、二叉树与图" class="headerlink" title="五、二叉树与图"></a>五、二叉树与图</h3><p>预备知识：二叉树定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;    <span class="comment">//数据域</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder_print</span><span class="params">(TreeNode *node,<span class="type">int</span> layer)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;layer;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]\n&quot;</span>,node-&gt;val);</span><br><span class="line">    <span class="built_in">preorder_print</span>(node-&gt;left,layer+<span class="number">1</span>);     <span class="comment">//遍历左子树</span></span><br><span class="line">    <span class="built_in">preorder_print</span>(node-&gt;right,layer+<span class="number">1</span>);    <span class="comment">//遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">d</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">e</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">f</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    a.left= &amp;b;</span><br><span class="line">    a.right=&amp;c;</span><br><span class="line">    b.left=&amp;d;</span><br><span class="line">    b.right=&amp;e;</span><br><span class="line">    c.right=&amp;f;</span><br><span class="line">    <span class="built_in">preorder_print</span>(&amp;a,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先序遍历、中序遍历、后序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">travelsal</span><span class="params">(TreeNode *node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;val);</span><br><span class="line">    <span class="built_in">travelsal</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">travelsal</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">travelsal</span><span class="params">(TreeNode *node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">travelsal</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;val);</span><br><span class="line">    <span class="built_in">travelsal</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">travelsal</span><span class="params">(TreeNode *node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">travelsal</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">travelsal</span>(node-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例1：路径之和（113）"><a href="#例1：路径之和（113）" class="headerlink" title="例1：路径之和（113）"></a>例1：路径之和（113）</h6><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p>
<p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">(<span class="type">int</span> sum,<span class="type">int</span> targetSum,vector&lt;<span class="type">int</span>&gt;&amp; temp,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;result,TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    sum+=node-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(!node-&gt;left&amp;&amp;!node-&gt;right&amp;&amp;sum==targetSum)</span><br><span class="line">    &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        sum-=node-&gt;val;</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">generate</span>(sum,targetSum,temp,result,node-&gt;left);</span><br><span class="line">    <span class="built_in">generate</span>(sum,targetSum,temp,result,node-&gt;right);</span><br><span class="line">    sum-=node-&gt;val;</span><br><span class="line">    temp.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">generate</span>(sum,targetSum,temp,result,root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例2：最近公共祖先（236）"><a href="#例2：最近公共祖先（236）" class="headerlink" title="例2：最近公共祖先（236）"></a>例2：最近公共祖先（236）</h6><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* node,TreeNode *search,vector&lt;TreeNode*&gt; &amp;path,vector&lt;TreeNode*&gt; &amp;result,<span class="type">int</span> &amp;finish)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node||finish)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(node);</span><br><span class="line">        <span class="keyword">if</span>(node==search)&#123;</span><br><span class="line">            finish=<span class="number">1</span>;</span><br><span class="line">            result=path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">preorder</span>(node-&gt;left,search,path,result,finish);</span><br><span class="line">        <span class="built_in">preorder</span>(node-&gt;right,search,path,result,finish);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; path;</span><br><span class="line">        vector&lt;TreeNode*&gt; node_p_path;</span><br><span class="line">        vector&lt;TreeNode*&gt; node_q_path;</span><br><span class="line">        <span class="type">int</span> finish=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root,p,path,node_p_path,finish);</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        finish=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root,q,path,node_q_path,finish);</span><br><span class="line">        <span class="type">int</span> path_len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node_p_path.<span class="built_in">size</span>()&lt;node_q_path.<span class="built_in">size</span>())&#123;</span><br><span class="line">            path_len=node_p_path.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            path_len=node_q_path.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path_len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node_p_path[i]==node_q_path[i])&#123;</span><br><span class="line">                result=node_p_path[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="例3：二叉树转链表（114）"><a href="#例3：二叉树转链表（114）" class="headerlink" title="例3：二叉树转链表（114）"></a>例3：二叉树转链表（114）</h6><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,null,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,null,<span class="number">2</span>,null,<span class="number">3</span>,null,<span class="number">4</span>,null,<span class="number">5</span>,null,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode *node,TreeNode *&amp;last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left&amp;&amp;!node-&gt;right)&#123;</span><br><span class="line">            last=node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *left=node-&gt;left;</span><br><span class="line">        TreeNode *right=node-&gt;right;</span><br><span class="line">        TreeNode *left_last=<span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *right_last=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(left)&#123;</span><br><span class="line">            <span class="built_in">preorder</span>(left,left_last);</span><br><span class="line">            node-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            node-&gt;right=left;</span><br><span class="line">            last=left_last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right)&#123;</span><br><span class="line">            <span class="built_in">preorder</span>(right,right_last);</span><br><span class="line">            <span class="keyword">if</span>(left_last)&#123;</span><br><span class="line">                left_last-&gt;right=right;</span><br><span class="line">            &#125;</span><br><span class="line">            last=right_last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *last=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root,last);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>$二叉数的层次遍历（宽度优先搜索）$</p>
</blockquote>
<p>层次遍历使用队列对遍历节点进行存储，先进入队列的节点，优先遍历扩展其左孩子与右孩子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;TreeNode*&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(&amp;a);</span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    TreeNode* temp=Q.<span class="built_in">front</span>();</span><br><span class="line">    Q.<span class="built_in">pop</span>();</span><br><span class="line">    cout&lt;&lt;temp-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例4：侧面观察二叉树（199）"><a href="#例4：侧面观察二叉树（199）" class="headerlink" title="例4：侧面观察二叉树（199）"></a>例4：侧面观察二叉树（199）</h6><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例:</p>
<p>输入: [1,2,3,null,5,null,4]<br>输出: [1, 3, 4]<br>解释:</p>
<p>   1            &lt;—<br> &#x2F;   <br>2     3         &lt;—<br> \     <br>  5     4       &lt;—</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;TreeNode*,<span class="type">int</span>&gt;&gt; Q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(root,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* node=Q.<span class="built_in">front</span>().first;</span><br><span class="line">        <span class="type">int</span> depth=Q.<span class="built_in">front</span>().second;</span><br><span class="line">        <span class="keyword">if</span>(depth==result.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[depth]=node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(node-&gt;left,depth+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(node-&gt;right,depth+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预备知识：图的定义</p>
<p>图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合，图分为有向图与无向图，根据图的边长又分为带权图与非带权图。</p>
<p>图的深度优先搜索与广度优先搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_graph</span><span class="params">(GraphNode* node,<span class="type">int</span> visit[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visit[node-&gt;label])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visit[node-&gt;label]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;label);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;node-&gt;neighbors.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[node-&gt;neighbors[i]-&gt;label]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">DFS_graph</span>(node-&gt;neighbors[i],visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_graph</span><span class="params">(GraphNode *node,<span class="type">int</span> visit[])</span></span>&#123;</span><br><span class="line">    queue&lt;GraphNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(node);</span><br><span class="line">    visit[node-&gt;label]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        GraphNode* node =Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;label);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;node-&gt;neighbors.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[node-&gt;neighbors[i]-&gt;label]==<span class="number">0</span>)&#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(node-&gt;neighbors[i]);</span><br><span class="line">                visit[node-&gt;neighbors[i]-&gt;label]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例5：课程安排（207）"><a href="#例5：课程安排（207）" class="headerlink" title="例5：课程安排（207）"></a>例5：课程安排（207）</h6><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p>
<p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
<p>示例 1：</p>
<p>输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]<br>输出：true<br>解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。<br>示例 2：</p>
<p>输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]<br>输出：false<br>解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS_graph</span><span class="params">(<span class="type">int</span> i,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph,vector&lt;<span class="type">int</span>&gt;&amp; visit)</span></span>&#123;</span><br><span class="line">    visit[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;graph[i].<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[graph[i][k]]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">DFS_graph</span>(graph[i][k],graph,visit))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visit[graph[i][k]]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[i]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visit</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prerequisites.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        graph[prerequisites[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="number">0</span>&amp;&amp;!<span class="built_in">DFS_graph</span>(i,graph,visit))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索，拓扑排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//图</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;   <span class="comment">//入度数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prerequisites.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        graph[prerequisites[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">        degree[prerequisites[i][<span class="number">1</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;degree.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(degree[i]==<span class="number">0</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> node=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph[node].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            degree[graph[node][i]]--;</span><br><span class="line">            <span class="keyword">if</span>(degree[graph[node][i]]==<span class="number">0</span>)</span><br><span class="line">                Q.<span class="built_in">push</span>(graph[node][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count==numCourses; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、二分查找与二叉查找树"><a href="#六、二分查找与二叉查找树" class="headerlink" title="六、二分查找与二叉查找树"></a>六、二分查找与二叉查找树</h3><p>二分查找又称折半查找，首先假设表中的元素是按照从大到小升序排序，将中间位的关键字与查找关键字比较：</p>
<p>1、如果两者相等，则查找成功；</p>
<p>2、否则利用中间位置将表分成前后两个子表：</p>
<p>​	1）如果中间位置的关键字大于查找关键字，则进一步查找前一子表</p>
<p>​	2）否则查找后一子表</p>
<p>重复以上操作直到找到关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;sort_array,<span class="type">int</span> begin,<span class="type">int</span> end,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin&gt;end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(begin+end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==sort_array[mid])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;sort_array[mid])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binary_search</span>(sort_array,begin,mid<span class="number">-1</span>,target);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binary_search</span>(sort_array,mid+<span class="number">1</span>,end,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环版</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;sort_array,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end=sort_array.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;=end)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(begin+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sort_array[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sort_array[mid]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            end=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            begin=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具有分治思想的问题一般使用循环解决问题；具有回溯思想的一般用递归实现。</p>
<p>例1：插入位置(35)</p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p>
<p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p>
<p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(index==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(begin+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            index=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==<span class="number">0</span>||target&gt;nums[mid<span class="number">-1</span>])&#123;</span><br><span class="line">                index=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            end=mid<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==nums.<span class="built_in">size</span>()<span class="number">-1</span>||target&lt;nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                index=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            begin=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例2：区间查找（34）"><a href="#例2：区间查找（34）" class="headerlink" title="例2：区间查找（34）"></a>例2：区间查找（34）</h6><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：</p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p>
<p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]</p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;=end)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(begin+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==<span class="number">0</span>||target&gt;nums[mid<span class="number">-1</span>])&#123;</span><br><span class="line">                result[<span class="number">0</span>]=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            end=mid<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">            end=mid<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid])&#123;</span><br><span class="line">            begin=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result[<span class="number">0</span>]==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    begin=<span class="number">0</span>;</span><br><span class="line">    end=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;=end)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(begin+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==nums.<span class="built_in">size</span>()<span class="number">-1</span>||target&lt;nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                result[<span class="number">1</span>]=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            begin=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">            end=mid<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid])&#123;</span><br><span class="line">            begin=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例3：旋转数组（33）"><a href="#例3：旋转数组（33）" class="headerlink" title="例3：旋转数组（33）"></a>例3：旋转数组（33）</h6><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p>
<p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;=end)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(begin+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[begin]&lt;nums[mid])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;=nums[begin])&#123;</span><br><span class="line">                        end=mid<span class="number">-1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        begin=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[begin]&gt;nums[mid])&#123;</span><br><span class="line">                    end=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[begin]==nums[mid])&#123;</span><br><span class="line">                    begin=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[begin]&lt;nums[mid])&#123;</span><br><span class="line">                    begin=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[begin]&gt;nums[mid])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;=nums[begin])&#123;</span><br><span class="line">                        end=mid<span class="number">-1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        begin=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[begin]==nums[mid])&#123;</span><br><span class="line">                    begin=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>预备知识：二叉排序树</p>
<p>一棵空树，或者是具有下列性质的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>：</p>
<p>（1）若左子树不空，则左子树上所有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%93%E7%82%B9/9794643">结点</a>的值均小于它的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93%E7%82%B9/9795570">根结点</a>的值；</p>
<p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>（3）左、右子树也分别为二叉排序树；</p>
<p>（4）没有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%94%AE%E5%80%BC/10086175">键值</a>相等的结点。</p>
<p>二叉查找树插入操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST_insert</span><span class="params">(TreeNode* node,TreeNode *insert_node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(insert_node-&gt;val&lt;node-&gt;val)&#123;	<span class="comment">//比较当前节点与根节点的数值大小</span></span><br><span class="line">       <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">           <span class="built_in">BST_insert</span>(node-&gt;left,insert_node);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           node-&gt;left=insert_node;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">BST_insert</span>(node-&gt;right,insert_node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node-&gt;right=insert_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉查找树查找操作</p>
<p>将某节点(insert_node)，插入至以node为根二叉查找树中: 如果 insert_node节点值 小于 当前node节点值: 如果node有左子树，则递归的将该节点插入至左子树为根二叉排序树中 否则，将node-&gt;left赋值为该节点地址 否则(大于等于情况): 如果node有右子树，则递归的将该节点插入至右子树为根二叉排序树中 否则，将node-&gt;right赋值为该节点地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BST_search</span><span class="params">(TreeNode *node,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;val==value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(value&lt;node-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">BST_search</span>(node-&gt;left,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(value&gt;node-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">BST_search</span>(node-&gt;right,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例4：二叉查找树的编码与解码-449"><a href="#例4：二叉查找树的编码与解码-449" class="headerlink" title="例4：二叉查找树的编码与解码(449)"></a>例4：二叉查找树的编码与解码(449)</h6><h3 id="七、哈希与字符串"><a href="#七、哈希与字符串" class="headerlink" title="七、哈希与字符串"></a>七、哈希与字符串</h3><p>预备知识：哈希表定义</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288">散列函数</a>，存放记录的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097">数组</a>叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>。</p>
<p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p>哈希表排序整数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> random[<span class="number">10</span>] = &#123;<span class="number">999</span>,<span class="number">1</span>,<span class="number">444</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> hash_map[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        hash_map[random[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;hash_map[i];j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预备知识：问题引入1，任意元素的映射</p>
<p>1、当遇到负整数或非常大的整数，如何进行哈希（映射）</p>
<p>2、入遇到字符串，如何进行哈希？</p>
<p>3当遇到其他无法直接映射的数据类型，如浮点数，数组、对象等，如何进行哈希</p>
<p>解决：</p>
<p>利用哈希函数，将关键字值转换为整数再对表取余，从而关键字值被转换为哈希表的表长范围的整数</p>
<p>哈希表映射产生冲突，解决方法：</p>
<p>1、拉链法解决冲突，构造哈希表</p>
<p>预备知识：哈希map与STL map</p>
<h6 id="例1：最长回文串（409）"><a href="#例1：最长回文串（409）" class="headerlink" title="例1：最长回文串（409）"></a>例1：最长回文串（409）</h6><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<p>注意:<br>假设字符串的长度不会超过 1010。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; hash_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash_map.<span class="built_in">find</span>(c)==hash_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                hash_map.<span class="built_in">insert</span>(&#123;c,<span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            hash_map[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item:hash_map)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.second%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                len+=item.second;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                len+=item.second<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len+flag;</span><br></pre></td></tr></table></figure>

<h6 id="例2：词语模式（290）"><a href="#例2：词语模式（290）" class="headerlink" title="例2：词语模式（290）"></a>例2：词语模式（290）</h6><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:</p>
<p>输入: pattern &#x3D; “abba”, str &#x3D; “dog cat cat dog”<br>输出: true<br>示例 2:</p>
<p>输入:pattern &#x3D; “abba”, str &#x3D; “dog cat cat fish”<br>输出: false<br>示例 3:</p>
<p>输入: pattern &#x3D; “aaaa”, str &#x3D; “dog cat cat dog”<br>输出: false<br>示例 4:</p>
<p>输入: pattern &#x3D; “abba”, str &#x3D; “dog dog dog dog”<br>输出: false<br>说明:<br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;string,<span class="type">char</span>&gt; hash_map;</span><br><span class="line">    <span class="type">char</span> used[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; words;</span><br><span class="line">    <span class="function">istringstream <span class="title">input</span><span class="params">(s)</span></span>;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">while</span>(input&gt;&gt;temp)&#123;</span><br><span class="line">        words.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(words.<span class="built_in">size</span>()!=pattern.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pattern.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_map.<span class="built_in">find</span>(words[i])==hash_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[pattern[i]]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            hash_map[words[i]]=pattern[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash_map[words[i]]!=pattern[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        used[pattern[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例3：同字符词语分组（49）"><a href="#例3：同字符词语分组（49）" class="headerlink" title="例3：同字符词语分组（49）"></a>例3：同字符词语分组（49）</h6><p>给定一个字符串数组，将字母异位词组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词指字母相同，但排列不同的字符串。</p>
<p> 示例 1:</p>
<p>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p>
<p>输入: strs &#x3D; [“”]<br>输出: [[“”]]<br>示例 3:</p>
<p>输入: strs &#x3D; [“a”]<br>输出: [[“a”]]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] 仅包含小写字母</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    unordered_map&lt;string,vector&lt;string&gt;&gt; hash_map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> str:strs)&#123;</span><br><span class="line">        string s=str;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(hash_map.<span class="built_in">find</span>(s)==hash_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            hash_map.<span class="built_in">insert</span>(&#123;s,<span class="built_in">vector</span>&lt;string&gt;()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        hash_map[s].<span class="built_in">push_back</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> vec:hash_map)&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(vec.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例4：无重复字符的最长字串（3）</p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p>示例 1:</p>
<p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p>
<p>输入: s &#x3D; “”<br>输出: 0</p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>s 由英文字母、数字、符号和空格组成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; hash_map;</span><br><span class="line">    <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_map.<span class="built_in">find</span>(s[i])==hash_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            hash_map[s[i]]=i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(result&lt;i-start)</span><br><span class="line">                result=i-start;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=hash_map[s[i]])</span><br><span class="line">                start=hash_map[s[i]]+<span class="number">1</span>;</span><br><span class="line">            hash_map[s[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result&lt;i-start)</span><br><span class="line">        result=i-start;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例5：重复的DNA序列（187）"><a href="#例5：重复的DNA序列（187）" class="headerlink" title="例5：重复的DNA序列（187）"></a>例5：重复的DNA序列（187）</h6><p>所有 DNA 都由一系列缩写为 ‘A’，’C’，’G’ 和 ‘T’ 的核苷酸组成，例如：”ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”,”CCCCCAAAAA”]<br>示例 2：</p>
<p>输入：s &#x3D; “AAAAAAAAAAAAA”<br>输出：[“AAAAAAAAAA”]</p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s[i] 为 ‘A’、’C’、’G’ 或 ‘T’</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; word_map;</span><br><span class="line">    <span class="type">int</span> end=s.<span class="built_in">length</span>()<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;end;i++)&#123;</span><br><span class="line">        string word=s.<span class="built_in">substr</span>(i,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(word_map.<span class="built_in">find</span>(word)==word_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            word_map.<span class="built_in">insert</span>(&#123;word,<span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        word_map[word]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> m:word_map)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.second&gt;=<span class="number">2</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(m.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例6：最小窗口子串（76）</p>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：</p>
<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”<br>示例 2：</p>
<p>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”<br>示例 3:</p>
<p>输入: s &#x3D; “a”, t &#x3D; “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; char_map;</span><br><span class="line">    <span class="type">int</span> len=t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(char_map.<span class="built_in">find</span>(c)==char_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            char_map.<span class="built_in">insert</span>(&#123;c,<span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        char_map[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> state=<span class="number">0</span>;</span><br><span class="line">    string result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(char_map.<span class="built_in">find</span>(s[i])!=char_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(start==<span class="number">-1</span>)</span><br><span class="line">                start=i;</span><br><span class="line">            char_map[s[i]]--;</span><br><span class="line">            <span class="keyword">if</span>(char_map[s[i]]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">                    result=s.<span class="built_in">substr</span>(start,i-start+<span class="number">1</span>);</span><br><span class="line">                    state=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(state==<span class="number">1</span>&amp;&amp;char_map[s[start]]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                char_map[s[start]]++;</span><br><span class="line">                start++;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(char_map.<span class="built_in">find</span>(s[start])==char_map.<span class="built_in">end</span>())</span><br><span class="line">                        start++;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(char_map[s[start]]==<span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            char_map[s[start]]++;</span><br><span class="line">                            start++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                string temp=s.<span class="built_in">substr</span>(start,i-start+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(temp.<span class="built_in">size</span>()&lt;result.<span class="built_in">size</span>())</span><br><span class="line">                    result=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、搜索"><a href="#八、搜索" class="headerlink" title="八、搜索"></a>八、搜索</h3><h6 id="例1：岛屿数量"><a href="#例1：岛屿数量" class="headerlink" title="例1：岛屿数量"></a>例1：岛屿数量</h6><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p>
<p>输入：grid &#x3D; [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mark,vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; grid,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    mark[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> newX=x+dx[i];</span><br><span class="line">        <span class="type">int</span> newY=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(newX&lt;<span class="number">0</span>||newX&gt;=mark.<span class="built_in">size</span>()||newY&lt;<span class="number">0</span>||newY&gt;=mark[newX].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark[newX][newY] == <span class="number">0</span> &amp;&amp; grid[newX][newY]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">DFS</span>(mark,grid,newX,newY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mark,vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;grid,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">    mark[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; node=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> newX=node.first+dx[i];</span><br><span class="line">            <span class="type">int</span> newY=node.second+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(newX&lt;<span class="number">0</span>||newX&gt;=mark.<span class="built_in">size</span>()||newY&lt;<span class="number">0</span>||newY&gt;=mark[newX].<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mark[newX][newY] == <span class="number">0</span> &amp;&amp; grid[newX][newY]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;newX,newY&#125;);</span><br><span class="line">                mark[newX][newY]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> island_num=<span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mark;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        mark.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(grid[i].<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mark[i][j]==<span class="number">0</span>&amp;&amp;grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">BFS</span>(mark,grid,i,j);</span><br><span class="line">                island_num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> island_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例2：词语阶梯（127）"><a href="#例2：词语阶梯（127）" class="headerlink" title="例2：词语阶梯（127）"></a>例2：词语阶梯（127）</h6><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p>
<p>序列中第一个单词是 beginWord 。<br>序列中最后一个单词是 endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典 wordList 中的单词。<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p>
<p>示例 1：</p>
<p>输入：beginWord &#x3D; “hit”, endWord &#x3D; “cog”, wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出：5<br>解释：一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, 返回它的长度 5。<br>示例 2：</p>
<p>输入：beginWord &#x3D; “hit”, endWord &#x3D; “cog”, wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出：0<br>解释：endWord “cog” 不在字典中，所以无法进行转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> string &amp;word1,<span class="type">const</span> string &amp;word2)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word1.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(word1[i]!=word2[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect_graph</span><span class="params">(string &amp;beginWord,vector&lt;string&gt;&amp; wordList,map&lt;string,vector&lt;string&gt;&gt; &amp;graph)</span></span>&#123;</span><br><span class="line">    wordList.<span class="built_in">push_back</span>(beginWord);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        graph[wordList[i]]=<span class="built_in">vector</span>&lt;string&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;wordList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">connect</span>(wordList[i],wordList[j]))&#123;</span><br><span class="line">                graph[wordList[i]].<span class="built_in">push_back</span>(wordList[j]);</span><br><span class="line">                graph[wordList[j]].<span class="built_in">push_back</span>(wordList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    map&lt;string,vector&lt;string&gt;&gt; graph;</span><br><span class="line">    <span class="built_in">connect_graph</span>(beginWord,wordList,graph);</span><br><span class="line">    map&lt;string,<span class="type">bool</span>&gt; visit;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        visit[wordList[i]]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(&#123;beginWord,<span class="number">1</span>&#125;);</span><br><span class="line">    visit[beginWord]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        string word=Q.<span class="built_in">front</span>().first;</span><br><span class="line">        <span class="type">int</span> seq=Q.<span class="built_in">front</span>().second;</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(word==endWord)</span><br><span class="line">            <span class="keyword">return</span> seq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph[word].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[graph[word][i]])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Q.<span class="built_in">push</span>(&#123;graph[word][i],seq+<span class="number">1</span>&#125;);</span><br><span class="line">            visit[graph[word][i]]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例3：词语阶梯3（126）"><a href="#例3：词语阶梯3（126）" class="headerlink" title="例3：词语阶梯3（126）"></a>例3：词语阶梯3（126）</h6><p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p>
<p>每对相邻的单词之间仅有单个字母不同。<br>转换过程中的每个单词 si（1 &lt;&#x3D; i &lt;&#x3D; k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。<br>sk &#x3D;&#x3D; endWord<br>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p>
<p>示例 1：</p>
<p>输入：beginWord &#x3D; “hit”, endWord &#x3D; “cog”, wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出：[[“hit”,”hot”,”dot”,”dog”,”cog”],[“hit”,”hot”,”lot”,”log”,”cog”]]<br>解释：存在 2 种最短的转换序列：<br>“hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”<br>“hit” -&gt; “hot” -&gt; “lot” -&gt; “log” -&gt; “cog”<br>示例 2：</p>
<p>输入：beginWord &#x3D; “hit”, endWord &#x3D; “cog”, wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出：[]<br>解释：endWord “cog” 不在字典 wordList 中，所以不存在符合要求的转换序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QItem</span>&#123;</span><br><span class="line">    string node;   <span class="comment">//搜索节点</span></span><br><span class="line">    <span class="type">int</span> parent_pos; <span class="comment">//前驱节点在队列中的位置</span></span><br><span class="line">    <span class="type">int</span> step;   <span class="comment">//  到达当前节点的步数</span></span><br><span class="line">    <span class="built_in">QItem</span>(string node,<span class="type">int</span> parent_pos,<span class="type">int</span> step):<span class="built_in">node</span>(node),<span class="built_in">parent_pos</span>(parent_pos),<span class="built_in">step</span>(step)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> string &amp;word1,<span class="type">const</span> string &amp;word2)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word1.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(word1[i]!=word2[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_graph</span><span class="params">(string &amp;beginWord,string &amp;endWord,map&lt;string,vector&lt;string&gt;&gt; &amp;graph,vector&lt;QItem&gt; &amp;Q,vector&lt;<span class="type">int</span>&gt; &amp;end_word_pos)</span></span>&#123;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; visit;</span><br><span class="line">    Q.<span class="built_in">push_back</span>(<span class="built_in">QItem</span>(beginWord,<span class="number">-1</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> min_step=<span class="number">0</span>;</span><br><span class="line">    visit[beginWord]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> front=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(front!=Q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">const</span> string &amp;node=Q[front].node;</span><br><span class="line">        <span class="type">int</span> step=Q[front].step;</span><br><span class="line">        <span class="keyword">if</span>(min_step!=<span class="number">0</span> &amp;&amp; step&gt;min_step)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node == endWord)&#123;</span><br><span class="line">            min_step=step;</span><br><span class="line">            end_word_pos.<span class="built_in">push_back</span>(front);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> vector&lt;string&gt; &amp;neighbors = graph[node];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;neighbors.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit.<span class="built_in">find</span>(neighbors[i])==visit.<span class="built_in">end</span>()||visit[neighbors[i]]==step+<span class="number">1</span>)&#123;</span><br><span class="line">                Q.<span class="built_in">push_back</span>(<span class="built_in">QItem</span>(neighbors[i],front,step+<span class="number">1</span>));</span><br><span class="line">                visit[neighbors[i]]=step+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct_graph</span><span class="params">(string &amp;beginWord,vector&lt;string&gt; &amp;wordList,map&lt;string,vector&lt;string&gt;&gt; &amp;graph)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> has_begin_word=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(wordList[i]==beginWord)&#123;</span><br><span class="line">            has_begin_word=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        graph[wordList[i]]=<span class="built_in">vector</span>&lt;string&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;wordList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">connect</span>(wordList[i],wordList[j]))&#123;</span><br><span class="line">                graph[wordList[i]].<span class="built_in">push_back</span>(wordList[j]);</span><br><span class="line">                graph[wordList[j]].<span class="built_in">push_back</span>(wordList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(has_begin_word == <span class="number">0</span> &amp;&amp; <span class="built_in">connect</span>(beginWord,wordList[i]))&#123;</span><br><span class="line">            graph[beginWord].<span class="built_in">push_back</span>(wordList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    map&lt;string,vector&lt;string&gt;&gt; graph;</span><br><span class="line">    <span class="built_in">construct_graph</span>(beginWord,wordList,graph);</span><br><span class="line">    vector&lt;QItem&gt; Q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; end_word_pos;</span><br><span class="line">    <span class="built_in">BFS_graph</span>(beginWord,endWord,graph,Q,end_word_pos);</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;end_word_pos.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> pos=end_word_pos[i];</span><br><span class="line">        vector&lt;string&gt; path;</span><br><span class="line">        <span class="keyword">while</span>(pos!=<span class="number">-1</span>)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(Q[pos].node);</span><br><span class="line">            pos=Q[pos].parent_pos;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;string&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=path.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            result[i].<span class="built_in">push_back</span>(path[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例4：火柴棍摆正方形（473）"><a href="#例4：火柴棍摆正方形（473）" class="headerlink" title="例4：火柴棍摆正方形（473）"></a>例4：火柴棍摆正方形（473）</h6><p>还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。</p>
<p>输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。</p>
<p>示例 1:</p>
<p>输入: [1,1,2,2,2]<br>输出: true</p>
<p>解释: 能拼成一个边长为2的正方形，每边两根火柴。<br>示例 2:</p>
<p>输入: [3,3,3,3,4]<br>输出: false</p>
<p>解释: 不能用所有火柴拼成一个正方形。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯方法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">generate</span><span class="params">(<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt;&amp; matchsticks,<span class="type">int</span> target,<span class="type">int</span> bucket[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==matchsticks.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> bucket[<span class="number">0</span>]==target&amp;&amp;bucket[<span class="number">1</span>]==target&amp;&amp;bucket[<span class="number">2</span>]==target&amp;&amp;bucket[<span class="number">3</span>]==target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bucket[j]+matchsticks[i]&gt;target)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[j]=bucket[j]+matchsticks[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">generate</span>(i+<span class="number">1</span>,matchsticks,target,bucket))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[j]=bucket[j]-matchsticks[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">makesquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; matchsticks)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matchsticks.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        sum+=matchsticks[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">4</span>!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> len=sum/<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">sort</span>(matchsticks.<span class="built_in">begin</span>(),matchsticks.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="type">int</span> &amp;lhs,<span class="type">const</span> <span class="type">int</span> &amp;rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs&gt;rhs;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> bucket[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">generate</span>(<span class="number">0</span>,matchsticks,len,bucket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位运算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">makesquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; matchsticks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matchsticks.<span class="built_in">size</span>()&lt;<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matchsticks.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        sum+=matchsticks[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">4</span>!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target=sum/<span class="number">4</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ok_subset; <span class="comment">//所有满足条件的一个边的集合</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ok_half; <span class="comment">//所有满足条件的两个边代表的集合</span></span><br><span class="line">    <span class="type">int</span> all=<span class="number">1</span>&lt;&lt;matchsticks.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;all;i++)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;matchsticks.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                sum+=matchsticks[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==target)</span><br><span class="line">            ok_subset.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ok_subset.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;ok_subset.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((ok_subset[i]&amp;ok_subset[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                ok_half.<span class="built_in">push_back</span>(ok_subset[i]|ok_subset[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ok_half.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;ok_half.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((ok_half[i]&amp;ok_half[j])==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例5：收集雨水（407）</p>
<p>给你一个 <code>m x n</code> 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>
<p>示例：</p>
<p>给出如下 3x6 的高度图:<br>[<br>  [1,4,3,1,3,2],<br>  [3,2,1,3,2,4],<br>  [2,3,3,2,3,1]<br>]</p>
<p>返回 4 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QItem</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="built_in">QItem</span>(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> h):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">h</span>(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> QItem &amp;l,<span class="type">const</span> QItem &amp;r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l.h&gt;r.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trapRainWater</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heightMap)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;QItem,vector&lt;QItem&gt;,cmp&gt; Q;</span><br><span class="line">    <span class="keyword">if</span>(heightMap.<span class="built_in">size</span>()&lt;<span class="number">3</span> || heightMap[<span class="number">0</span>].<span class="built_in">size</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> row=heightMap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> column=heightMap[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mark;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        mark.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;column;j++)&#123;</span><br><span class="line">            mark[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(<span class="built_in">QItem</span>(i,<span class="number">0</span>,heightMap[i][<span class="number">0</span>]));</span><br><span class="line">        mark[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        Q.<span class="built_in">push</span>(<span class="built_in">QItem</span>(i,column<span class="number">-1</span>,heightMap[i][column<span class="number">-1</span>]));</span><br><span class="line">        mark[i][column<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;column;i++)&#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(<span class="built_in">QItem</span>(<span class="number">0</span>,i,heightMap[<span class="number">0</span>][i]));</span><br><span class="line">        mark[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        Q.<span class="built_in">push</span>(<span class="built_in">QItem</span>(row<span class="number">-1</span>,i,heightMap[row<span class="number">-1</span>][i]));</span><br><span class="line">        mark[row<span class="number">-1</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> result=<span class="number">0</span>;  <span class="comment">//最终积水量</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=Q.<span class="built_in">top</span>().x;</span><br><span class="line">        <span class="type">int</span> y=Q.<span class="built_in">top</span>().y;</span><br><span class="line">        <span class="type">int</span> h=Q.<span class="built_in">top</span>().h;</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> newX=x+dx[i];</span><br><span class="line">            <span class="type">int</span> newY=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(newX&lt;<span class="number">0</span>||newX&gt;=row||newY&lt;<span class="number">0</span>||newY&gt;=column||mark[newX][newY])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(h&gt;heightMap[newX][newY])&#123;</span><br><span class="line">                result+=h-heightMap[newX][newY];</span><br><span class="line">                heightMap[newX][newY]=h;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.<span class="built_in">push</span>(<span class="built_in">QItem</span>(newX,newY,heightMap[newX][newY]));</span><br><span class="line">            mark[newX][newY]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、动态规划"><a href="#九、动态规划" class="headerlink" title="九、动态规划"></a>九、动态规划</h3><h6 id="例1、爬楼梯（70）"><a href="#例1、爬楼梯（70）" class="headerlink" title="例1、爬楼梯（70）"></a>例1、爬楼梯（70）</h6><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">return</span> f[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例2：打家劫舍（198）"><a href="#例2：打家劫舍（198）" class="headerlink" title="例2：打家劫舍（198）"></a>例2：打家劫舍（198）</h6><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() ==<span class="number">1</span> ) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],f[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="例3：最大字段和（53）"><a href="#例3：最大字段和（53）" class="headerlink" title="例3：最大字段和（53）"></a>例3：最大字段和（53）</h6><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums &#x3D; [0]<br>输出：0<br>示例 4：</p>
<p>输入：nums &#x3D; [-1]<br>输出：-1<br>示例 5：</p>
<p>输入：nums &#x3D; [-100000]<br>输出：-100000</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxx=nums[<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(maxx&lt;f[i])</span><br><span class="line">            maxx=f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例4：找零钱（322）"><a href="#例4：找零钱（322）" class="headerlink" title="例4：找零钱（322）"></a>例4：找零钱（322）</h6><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<p>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + 1<br>示例 2：</p>
<p>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1<br>示例 3：</p>
<p>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0<br>示例 4：</p>
<p>输入：coins &#x3D; [1], amount &#x3D; 1<br>输出：1<br>示例 5：</p>
<p>输入：coins &#x3D; [1], amount &#x3D; 2<br>输出：2</p>
<p>提示：</p>
<p>1 &lt;&#x3D; coins.length &lt;&#x3D; 12<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; amount &lt;&#x3D; 104</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change">https://leetcode-cn.com/problems/coin-change</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;coins.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=coins[k]&amp;&amp;dp[i-coins[k]]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] == <span class="number">-1</span> ||dp[i]&gt;dp[i-coins[k]]+<span class="number">1</span>)</span><br><span class="line">                    dp[i]=dp[i-coins[k]]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例5：三角形（120）"><a href="#例5：三角形（120）" class="headerlink" title="例5：三角形（120）"></a>例5：三角形（120）</h6><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<p>示例 1：</p>
<p>输入：triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br>  3 4<br> 6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。<br>示例 2：</p>
<p>输入：triangle &#x3D; [[-10]]<br>输出：-10</p>
<p>提示：</p>
<p>1 &lt;&#x3D; triangle.length &lt;&#x3D; 200<br>triangle[0].length &#x3D;&#x3D; 1<br>triangle[i].length &#x3D;&#x3D; triangle[i - 1].length + 1<br>-104 &lt;&#x3D; triangle[i][j] &lt;&#x3D; 104</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    dp.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;triangle[<span class="number">0</span>][<span class="number">0</span>]&#125;));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;triangle.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(triangle[i].<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;triangle[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>) dp[i][j]=dp[i<span class="number">-1</span>][j]+triangle[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==triangle[i<span class="number">-1</span>].<span class="built_in">size</span>()) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+triangle[i][j];</span><br><span class="line">            <span class="keyword">else</span>  dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j])+triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> MIN=dp[dp.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp[dp.<span class="built_in">size</span>()<span class="number">-1</span>].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(MIN&gt;dp[dp.<span class="built_in">size</span>()<span class="number">-1</span>][i])</span><br><span class="line">            MIN=dp[dp.<span class="built_in">size</span>()<span class="number">-1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例6：最长上升子序列（300）</p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p>
<p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> maxx=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[j]&amp;&amp;dp[i]&lt;dp[j]+<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxx&lt;dp[i])</span><br><span class="line">            maxx=dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例7：最小路径和（64）</p>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p>
<p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12</p>
<p>提示：</p>
<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum">https://leetcode-cn.com/problems/minimum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">   vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(grid.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>(),<span class="number">-1</span>));</span><br><span class="line">   dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(dp[i][j]==<span class="number">-1</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j])+grid[i][j];</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span>) dp[i][j]=dp[i<span class="number">-1</span>][j]+grid[i][j];</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>) dp[i][j]=dp[i][j<span class="number">-1</span>]+grid[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[dp.<span class="built_in">size</span>()<span class="number">-1</span>][dp[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>];     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例8：地牢游戏（174）</p>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<p>-2 (K)	-3	3<br>-5	-10	1<br>10	30	-5 (P)</p>
<p>说明:</p>
<p>骑士的健康点数没有上限。</p>
<p>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dungeon-game">https://leetcode-cn.com/problems/dungeon-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=dungeon.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m=dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    dp[n<span class="number">-1</span>][m<span class="number">-1</span>]=dungeon[n<span class="number">-1</span>][m<span class="number">-1</span>]&lt;<span class="number">0</span>?<span class="number">0</span>-dungeon[n<span class="number">-1</span>][m<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n<span class="number">-1</span> &amp;&amp;j==m<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>&amp;&amp;j&lt;m<span class="number">-1</span>)&#123;</span><br><span class="line">                dp[i][j]=dungeon[i][j]-<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)  dp[i][j]=dungeon[i][j]-dp[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;m<span class="number">-1</span>)  dp[i][j]=dungeon[i][j]-dp[i][j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]&gt;<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=<span class="number">0</span>-dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十、复杂数据结构"><a href="#十、复杂数据结构" class="headerlink" title="十、复杂数据结构"></a>十、复杂数据结构</h3><p>字典树,又称前缀树，又称单词查找树，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Trie%E6%A0%91">Trie树</a>，是一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/9663807">树形结构</a>，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6">字符</a>串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<p>Tries树前序遍历，实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRIE_MAX_CHAR_NUM 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">    TrieNode *child[TRIE_MAX_CHAR_NUM];</span><br><span class="line">    <span class="type">bool</span> is_end;</span><br><span class="line">    <span class="built_in">TrieNode</span>():<span class="built_in">is_end</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TRIE_MAX_CHAR_NUM;i++)&#123;</span><br><span class="line">            child[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder_trie</span><span class="params">(TrieNode *node,<span class="type">int</span> layer)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TRIE_MAX_CHAR_NUM;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;child[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;layer;j++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,i+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;child[i]-&gt;is_end)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(end)&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">preorder_trie</span>(node-&gt;child[i],layer+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    TrieNode n1;</span><br><span class="line">    TrieNode n2;</span><br><span class="line">    TrieNode n3;</span><br><span class="line">    root.child[<span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n1;</span><br><span class="line">    root.child[<span class="string">&#x27;b&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n2;</span><br><span class="line">    root.child[<span class="string">&#x27;e&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n3;</span><br><span class="line">    n2.is_end=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    TrieNode n4;</span><br><span class="line">    TrieNode n5;</span><br><span class="line">    TrieNode n6;</span><br><span class="line">    n1.child[<span class="string">&#x27;b&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n4;</span><br><span class="line">    n2.child[<span class="string">&#x27;c&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n5;</span><br><span class="line">    n3.child[<span class="string">&#x27;f&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n6;</span><br><span class="line"></span><br><span class="line">    TrieNode n7;</span><br><span class="line">    TrieNode n8;</span><br><span class="line">    TrieNode n9;</span><br><span class="line">    TrieNode n10;</span><br><span class="line"></span><br><span class="line">    n4.child[<span class="string">&#x27;c&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n7;</span><br><span class="line">    n4.child[<span class="string">&#x27;d&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n8;</span><br><span class="line">    n5.child[<span class="string">&#x27;d&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n9;</span><br><span class="line">    n6.child[<span class="string">&#x27;g&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n10;</span><br><span class="line">    n7.is_end=<span class="literal">true</span>;</span><br><span class="line">    n8.is_end=<span class="literal">true</span>;</span><br><span class="line">    n9.is_end=<span class="literal">true</span>;</span><br><span class="line">    n10.is_end=<span class="literal">true</span>;</span><br><span class="line">    TrieNode n11;</span><br><span class="line">    n7.child[<span class="string">&#x27;d&#x27;</span>-<span class="string">&#x27;a&#x27;</span>]=&amp;n11;</span><br><span class="line">    n11.is_end=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">preorder_trie</span>(&amp;root,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="例1：实现trie树（208）"><a href="#例1：实现trie树（208）" class="headerlink" title="例1：实现trie树（208）"></a>例1：实现trie树（208）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRIE_MAX_CHAR_NUM 26</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">    TrieNode *child[TRIE_MAX_CHAR_NUM];</span><br><span class="line">    <span class="type">bool</span> is_end;</span><br><span class="line">    <span class="built_in">TrieNode</span>():<span class="built_in">is_end</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TRIE_MAX_CHAR_NUM;i++)&#123;</span><br><span class="line">            child[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TrieTree</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">TrieTree</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;_node_vec.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _node_vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *word)</span></span>&#123;</span><br><span class="line">        TrieNode *ptr = &amp;_root;</span><br><span class="line">        <span class="keyword">while</span>(*word)&#123;</span><br><span class="line">            <span class="type">int</span> pos=*word-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ptr-&gt;child[pos])&#123;</span><br><span class="line">                ptr-&gt;child[pos]=<span class="built_in">new_node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;child[pos];</span><br><span class="line">            word++;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;is_end=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *word)</span></span>&#123;</span><br><span class="line">        TrieNode *ptr = &amp;_root;</span><br><span class="line">        <span class="keyword">while</span>(*word)&#123;</span><br><span class="line">            <span class="type">int</span> pos=*word-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ptr-&gt;child[pos])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=ptr-&gt;child[pos];</span><br><span class="line">            word++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *prefix)</span></span>&#123;</span><br><span class="line">        TrieNode *ptr=&amp;_root;</span><br><span class="line">        <span class="keyword">while</span>(*prefix)&#123;</span><br><span class="line">            <span class="type">int</span> pos=*prefix-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ptr-&gt;child[pos])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=ptr-&gt;child[pos];</span><br><span class="line">            prefix++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TrieNode *<span class="title">root</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;_root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TrieNode *<span class="title">new_node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TrieNode *node=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        _node_vec.<span class="built_in">push_back</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;TrieNode*&gt; _node_vec;</span><br><span class="line">    TrieNode _root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="例2：添加与查找单词（211）"><a href="#例2：添加与查找单词（211）" class="headerlink" title="例2：添加与查找单词（211）"></a>例2：添加与查找单词（211）</h6><p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 WordDictionary ：</p>
<p>WordDictionary() 初始化词典对象<br>void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配<br>bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 ‘.’ ，每个 . 都可以表示任何一个字母。</p>
<p>示例：</p>
<p>输入：<br>[“WordDictionary”,”addWord”,”addWord”,”addWord”,”search”,”search”,”search”,”search”]<br>[[],[“bad”],[“dad”],[“mad”],[“pad”],[“bad”],[“.ad”],[“b..”]]<br>输出：<br>[null,null,null,null,false,true,true,true]</p>
<p>解释：<br>WordDictionary wordDictionary &#x3D; new WordDictionary();<br>wordDictionary.addWord(“bad”);<br>wordDictionary.addWord(“dad”);<br>wordDictionary.addWord(“mad”);<br>wordDictionary.search(“pad”); &#x2F;&#x2F; return False<br>wordDictionary.search(“bad”); &#x2F;&#x2F; return True<br>wordDictionary.search(“.ad”); &#x2F;&#x2F; return True<br>wordDictionary.search(“b..”); &#x2F;&#x2F; return True</p>
<p>提示：</p>
<p>1 &lt;&#x3D; word.length &lt;&#x3D; 500<br>addWord 中的 word 由小写英文字母组成<br>search 中的 word 由 ‘.’ 或小写英文字母组成<br>最多调用 50000 次 addWord 和 search</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search_trie</span><span class="params">(TrieNode *node,<span class="type">const</span> <span class="type">char</span> *word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*word == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;is_end)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*word == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TRIE_MAX_CHAR_NUM;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;child[i] &amp;&amp; <span class="built_in">search_trie</span>(node-&gt;child[i],word+<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pos=*word-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;child[pos] &amp;&amp; <span class="built_in">search_trie</span>(node-&gt;child[pos],word+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="例3：朋友圈（547）"><a href="#例3：朋友圈（547）" class="headerlink" title="例3：朋友圈（547）"></a>例3：朋友圈（547）</h6><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<p>示例 1：</p>
<p>输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2<br>示例 2：</p>
<p>输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3</p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 200<br>n &#x3D;&#x3D; isConnected.length<br>n &#x3D;&#x3D; isConnected[i].length<br>isConnected[i][j] 为 1 或 0<br>isConnected[i][i] &#x3D;&#x3D; 1<br>isConnected[i][j] &#x3D;&#x3D; isConnected[j][i]</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces">https://leetcode-cn.com/problems/number-of-provinces</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_graph</span><span class="params">(<span class="type">int</span> u,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph,vector&lt;<span class="type">int</span>&gt;&amp; visit)</span></span>&#123;</span><br><span class="line">    visit[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; graph[u].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i] == <span class="number">0</span> &amp;&amp; graph[u][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">DFS_graph</span>(i,graph,visit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visit</span><span class="params">(M.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">DFS_graph</span>(i,M,visit);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并查集：</p>
<p>数组实现并查集</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSet</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置集合数组id[i],初始时每个元素构成一个单元素集合，编号为i的元素的集合i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">DisjointSet</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            _id.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _id[p];  <span class="comment">//查询元素p属于哪个集合直接返回id[p]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pid = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="type">int</span> qid = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> ( pid == qid )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _id.<span class="built_in">size</span>(); i++)&#123;   <span class="comment">//将所有属于pid的集合全部改为qid的集合</span></span><br><span class="line">            <span class="keyword">if</span> (_id[i] == pid)&#123;</span><br><span class="line">                _id[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _id.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;集合： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _id.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,_id[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; _id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">DisjointSet <span class="title">disjoint_set</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    disjoint_set.<span class="built_in">print_set</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Union(0,5)\n&quot;</span>);</span><br><span class="line">    disjoint_set.<span class="built_in">union_</span>(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">    disjoint_set.<span class="built_in">print_set</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Find(0) = %d ,Find(5) = %d\n&quot;</span>,disjoint_set.<span class="built_in">find</span>(<span class="number">0</span>),disjoint_set.<span class="built_in">find</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Find(2) = %d ,Find(5) = %d\n&quot;</span>,disjoint_set.<span class="built_in">find</span>(<span class="number">2</span>),disjoint_set.<span class="built_in">find</span>(<span class="number">5</span>));</span><br><span class="line">    disjoint_set.<span class="built_in">union_</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    disjoint_set.<span class="built_in">print_set</span>();</span><br><span class="line">    disjoint_set.<span class="built_in">union_</span>(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">    disjoint_set.<span class="built_in">print_set</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Find(2) = %d ,Find(5) = %d\n&quot;</span>,disjoint_set.<span class="built_in">find</span>(<span class="number">2</span>),disjoint_set.<span class="built_in">find</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSet</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置集合数组id[i],初始时每个元素构成一个单元素集合，编号为i的元素的集合i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">DisjointSet</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            _id.<span class="built_in">push_back</span>(i);</span><br><span class="line">            _size.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _count = n;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p != _id[p])&#123;</span><br><span class="line">            _id[p] = _id[_id[p]];</span><br><span class="line">            p = _id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span>( i == j)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(_size[i] &lt; _size[j])&#123;</span><br><span class="line">            _id[i] = j;</span><br><span class="line">            _size[j] += _size[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            _id[j] = i;</span><br><span class="line">            _size[i] += _size[j];</span><br><span class="line">        &#125;</span><br><span class="line">        _count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _id.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;集合： &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _id.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,_id[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; _id;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; _size;</span><br><span class="line">    <span class="type">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="function">DisjointSet <span class="title">disjoint_set</span><span class="params">(M.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j &lt; M.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j])&#123;</span><br><span class="line">                    disjoint_set.<span class="built_in">union_</span>(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> disjoint_set.<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; M=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Solution s;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">findCircleNum</span>(M)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例4：区域和的查询（307）</p>
<p>线段树的构造</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Kirito</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">http://example.com/2022/08/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Kirito博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kirito</div><div class="author-info__description">心若向阳，无畏悲伤。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ShawNight" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/3152405926@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86"><span class="toc-number">1.0.1.</span> <span class="toc-text">一、栈、队列与堆</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B1%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">1.0.1.0.0.1.</span> <span class="toc-text">例1：使用队列实现栈</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">1.0.1.0.0.2.</span> <span class="toc-text">例2：使用栈实现队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E5%B8%A6%E6%9C%89min%E7%9A%84%E6%A0%88"><span class="toc-number">1.0.1.0.0.3.</span> <span class="toc-text">例3：带有min的栈</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B4%EF%BC%9A%E5%90%88%E6%B3%95%E7%9A%84%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97"><span class="toc-number">1.0.1.0.0.4.</span> <span class="toc-text">例4：合法的出栈序列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B5%EF%BC%9A%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0"><span class="toc-number">1.0.1.0.0.5.</span> <span class="toc-text">例5：第K大的数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B6%EF%BC%9A%E5%AF%BB%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">1.0.1.0.0.6.</span> <span class="toc-text">例6：寻找中位数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.0.2.</span> <span class="toc-text">二、链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.3.</span> <span class="toc-text">三、贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B1%EF%BC%9A%E5%88%86%E7%B3%96%E6%9E%9C"><span class="toc-number">1.0.3.0.0.1.</span> <span class="toc-text">例1：分糖果</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E6%91%87%E6%91%86%E5%BA%8F%E5%88%97"><span class="toc-number">1.0.3.0.0.2.</span> <span class="toc-text">例2：摇摆序列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E7%A7%BB%E9%99%A4K%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%88402%EF%BC%89"><span class="toc-number">1.0.3.0.0.3.</span> <span class="toc-text">例3：移除K个数字（402）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B4%EF%BC%9A%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-55"><span class="toc-number">1.0.3.0.0.4.</span> <span class="toc-text">例4：跳跃游戏(55)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B5%EF%BC%9A%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F2-%EF%BC%8845%EF%BC%89"><span class="toc-number">1.0.3.0.0.5.</span> <span class="toc-text">例5：跳跃游戏2 （45）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B6%EF%BC%9A%E5%B0%84%E5%87%BB%E6%B0%94%E7%90%83-452"><span class="toc-number">1.0.3.0.0.6.</span> <span class="toc-text">例6：射击气球(452)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B7%EF%BC%9A%E6%9C%80%E4%BC%98%E5%8A%A0%E6%B2%B9%E6%96%B9%E6%B3%95%EF%BC%882431%EF%BC%89"><span class="toc-number">1.0.3.0.0.7.</span> <span class="toc-text">例7：最优加油方法（2431）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%B8%8E%E5%88%86%E6%B2%BB"><span class="toc-number">1.0.4.</span> <span class="toc-text">四、递归回溯与分治</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B1%EF%BC%9A%E6%B1%82%E5%AD%90%E9%9B%86"><span class="toc-number">1.0.4.0.0.1.</span> <span class="toc-text">例1：求子集</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E7%94%9F%E4%BA%A7%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.0.4.0.0.2.</span> <span class="toc-text">例2：生产括号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E7%BB%84%E5%90%88%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.0.4.0.0.3.</span> <span class="toc-text">例3：组合数之和</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B4%EF%BC%9AN%E7%9A%87%E5%90%8E"><span class="toc-number">1.0.4.0.0.4.</span> <span class="toc-text">例4：N皇后</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B5%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.4.0.0.5.</span> <span class="toc-text">例5：归并排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B6%EF%BC%9A%E9%80%86%E5%BA%8F%E6%95%B0"><span class="toc-number">1.0.4.0.0.6.</span> <span class="toc-text">例6：逆序数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%9B%BE"><span class="toc-number">1.0.5.</span> <span class="toc-text">五、二叉树与图</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B1%EF%BC%9A%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%EF%BC%88113%EF%BC%89"><span class="toc-number">1.0.5.0.0.1.</span> <span class="toc-text">例1：路径之和（113）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88236%EF%BC%89"><span class="toc-number">1.0.5.0.0.2.</span> <span class="toc-text">例2：最近公共祖先（236）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88114%EF%BC%89"><span class="toc-number">1.0.5.0.0.3.</span> <span class="toc-text">例3：二叉树转链表（114）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B4%EF%BC%9A%E4%BE%A7%E9%9D%A2%E8%A7%82%E5%AF%9F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88199%EF%BC%89"><span class="toc-number">1.0.5.0.0.4.</span> <span class="toc-text">例4：侧面观察二叉树（199）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B5%EF%BC%9A%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92%EF%BC%88207%EF%BC%89"><span class="toc-number">1.0.5.0.0.5.</span> <span class="toc-text">例5：课程安排（207）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">1.0.6.</span> <span class="toc-text">六、二分查找与二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E5%8C%BA%E9%97%B4%E6%9F%A5%E6%89%BE%EF%BC%8834%EF%BC%89"><span class="toc-number">1.0.6.0.0.1.</span> <span class="toc-text">例2：区间查找（34）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%8833%EF%BC%89"><span class="toc-number">1.0.6.0.0.2.</span> <span class="toc-text">例3：旋转数组（33）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B4%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81-449"><span class="toc-number">1.0.6.0.0.3.</span> <span class="toc-text">例4：二叉查找树的编码与解码(449)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%93%88%E5%B8%8C%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.7.</span> <span class="toc-text">七、哈希与字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B1%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88409%EF%BC%89"><span class="toc-number">1.0.7.0.0.1.</span> <span class="toc-text">例1：最长回文串（409）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E8%AF%8D%E8%AF%AD%E6%A8%A1%E5%BC%8F%EF%BC%88290%EF%BC%89"><span class="toc-number">1.0.7.0.0.2.</span> <span class="toc-text">例2：词语模式（290）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E5%90%8C%E5%AD%97%E7%AC%A6%E8%AF%8D%E8%AF%AD%E5%88%86%E7%BB%84%EF%BC%8849%EF%BC%89"><span class="toc-number">1.0.7.0.0.3.</span> <span class="toc-text">例3：同字符词语分组（49）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B5%EF%BC%9A%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97%EF%BC%88187%EF%BC%89"><span class="toc-number">1.0.7.0.0.4.</span> <span class="toc-text">例5：重复的DNA序列（187）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%90%9C%E7%B4%A2"><span class="toc-number">1.0.8.</span> <span class="toc-text">八、搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B1%EF%BC%9A%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">1.0.8.0.0.1.</span> <span class="toc-text">例1：岛屿数量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E8%AF%8D%E8%AF%AD%E9%98%B6%E6%A2%AF%EF%BC%88127%EF%BC%89"><span class="toc-number">1.0.8.0.0.2.</span> <span class="toc-text">例2：词语阶梯（127）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E8%AF%8D%E8%AF%AD%E9%98%B6%E6%A2%AF3%EF%BC%88126%EF%BC%89"><span class="toc-number">1.0.8.0.0.3.</span> <span class="toc-text">例3：词语阶梯3（126）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B4%EF%BC%9A%E7%81%AB%E6%9F%B4%E6%A3%8D%E6%91%86%E6%AD%A3%E6%96%B9%E5%BD%A2%EF%BC%88473%EF%BC%89"><span class="toc-number">1.0.8.0.0.4.</span> <span class="toc-text">例4：火柴棍摆正方形（473）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.0.9.</span> <span class="toc-text">九、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B1%E3%80%81%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%8870%EF%BC%89"><span class="toc-number">1.0.9.0.0.1.</span> <span class="toc-text">例1、爬楼梯（70）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%88198%EF%BC%89"><span class="toc-number">1.0.9.0.0.2.</span> <span class="toc-text">例2：打家劫舍（198）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%97%E6%AE%B5%E5%92%8C%EF%BC%8853%EF%BC%89"><span class="toc-number">1.0.9.0.0.3.</span> <span class="toc-text">例3：最大字段和（53）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B4%EF%BC%9A%E6%89%BE%E9%9B%B6%E9%92%B1%EF%BC%88322%EF%BC%89"><span class="toc-number">1.0.9.0.0.4.</span> <span class="toc-text">例4：找零钱（322）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B5%EF%BC%9A%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88120%EF%BC%89"><span class="toc-number">1.0.9.0.0.5.</span> <span class="toc-text">例5：三角形（120）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.10.</span> <span class="toc-text">十、复杂数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B1%EF%BC%9A%E5%AE%9E%E7%8E%B0trie%E6%A0%91%EF%BC%88208%EF%BC%89"><span class="toc-number">1.0.10.0.0.1.</span> <span class="toc-text">例1：实现trie树（208）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B2%EF%BC%9A%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%9F%A5%E6%89%BE%E5%8D%95%E8%AF%8D%EF%BC%88211%EF%BC%89"><span class="toc-number">1.0.10.0.0.2.</span> <span class="toc-text">例2：添加与查找单词（211）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B3%EF%BC%9A%E6%9C%8B%E5%8F%8B%E5%9C%88%EF%BC%88547%EF%BC%89"><span class="toc-number">1.0.10.0.0.3.</span> <span class="toc-text">例3：朋友圈（547）</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="算法与数据结构"><img src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法与数据结构"/></a><div class="content"><a class="title" href="/2022/08/21/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="算法与数据结构">算法与数据结构</a><time datetime="2022-08-21T14:20:05.000Z" title="发表于 2022-08-21 22:20:05">2022-08-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Kirito</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>